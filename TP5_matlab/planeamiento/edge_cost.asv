function cost = edge_cost(parent, child, map)
  
    
    cost = 0;
 
    %%% YOUR CODE FOR CALCULATING THE COST FROM VERTEX parent TO VERTEX child GOES HERE
    
    child_y = child(1);
    child_x = child(2);
    
    cost_child =  map(child_y, child_x);
    % Umbral del costo. Se eligió este valor según la imagen que se obtuvo
    % a partir de la matrix map. Se obse
    if cost_child  > 0.4 
        cost = cost + inf;
    end
    
    dist_pc = norm(parent - child); % Distance parent to child 
    
    k_D_cost = 1;
    k_D_dist = 1;
    
    %%
    
    % Descomentar el siguiente if si se quiere dar un costo mucho mayor
    % a los nodos diagonales y con esto hacer que el robot nunca planee una
    % trayectoria con este tipo de movimientos
    
    %if dist_pc == sqrt(2)
    %    dist_pc = dist_pc*10;  
    %end
    
    %%
    
    % Esto fue un intento no exitoso de agregar costo a aquellos children
    % que no tengan un obstáculo en uno de sus nodos adyacentes de forma tal
    % de que se elijan aquellos nodos que se encuentren al lado de una
    % pared u obstáculo. El objetivo principal de esta parte del código era
    % lograr que el robot se mantenga siempre al lado de una pared u
    % obstáculo
    
    %obs_n = map(child(1) + 1, child(1) ) > 0.4; % obstáculo al norte
    %obs_s = map(child(1) - 1, child(1) ) > 0.4; % obstáculo al sur
    %obs_e = map(child(1), child(1) + 1 ) > 0.4; % obstáculo al este
    %obs_w = map(child(1), child(1) - 1 ) > 0.4; % obstáculo al oeste
    %if ~(obs_n || obs_s || obs_e || obs_w)
    %    cost = cost + 10;
    %end
    
    
    
    %%
    
    
    
    
    cost = cost + k_D_dist * dist_pc + k_D_cost *cost_child; % Usar este costo, los otros son de prueba
    
    %cost = cost + dist_pc;
    %cost = cost +  1 +  k_D*cost_child;
        
end